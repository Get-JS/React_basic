# Why React?

- 리액트는 **`JS 라이브리로`** 유저 인터페이스를 만드는데 사용한다.
- 구조가 `MVC, MVW등인 프레임워크`와 달리, 오직 **`V(VIEW)만 신경쓰는 라이브러리이다.`**
- 리액트 프로젝트에서 특정 부분이 어떻게 생길지 정하는 선언체를 **`컴포넌트(Component)라고`** 한다.

## 컴포넌트

- 컴포넌트는 **`재사용이 가능한 API로`** 수많은 기능들을 내장하고 있다.
- 컴포넌트 하나에서 **`해당 컴포넌트의 생김새와 작동 방식을 정의한다.`**
- 컴포넌트 **`상태값은 불변 객체로 관리해야 한다.`**

## 초기 렌더링

- 어떤 UI를 처음에 어떻게 보일지를 정하는 초기 렌더링이 필요하다.
- 리액트에서는 이를 다루는 render 함수가 있다.

```js
render() {}
```

- 이 함수는 `컴포넌트가` 어떻게 생겼는지 **`정의하는 역할을`** 한다.
- render 함수내에는 **`순수 함수로`** 작성해야 한다.
- html 형식의 문자열을 반환하지 않고, **뷰가 어떻게 생겼고 어떻게 작동하는지 정보를 지닌 객체를 반환한다.**
- render 함수를 실행하면 그 **`내부에 있는 컴포넌트들도 재귀적으로 렌더링한다.`** 
- 이렇게 최상위 컴포넌트의 렌더링 작업이 끝나면 **`지니고 있는 정보들을 사용하여 HTML 마크업을 만들고`,** 이를 우리가 정하는 **`실제 페이지의 DOM 요소 안에 주입한다.`**
- 렌더링할 때는
  1. `문자열 형태의 HTML 코드를 생성`
  2. `특정 DOM에 해당 내용을 주입`
  3. `이벤트 적용`

## 조화과정(reconciliation)

- 컴포넌트에서 데이터에 변화가 있을 때 우리가 보기에는 `변화에 따라 뷰가 변형되는 것처럼 보이지만,` **`사실은 새로운 요소로 교체 한다.`**
- 이 또한 render함수에 기능이 내장 되어 있다.
- 컴포넌트는 데이터를 업데이트했을 때 `단순히 업데이트한 값을 수정하는 것이 아니라,` **`새로운 데이터를 가지고 render함수를 또 다시 호출한다.`**
- 하지만, 이때 render 함수가 반화는 `결과를 곧바로 DOM에 반영하지 않고,` 이전에 render 함수가 만들었던 컴포넌트 정보와 현재 render 함수가 만든 **`컴포넌트 정보를 비교 한다.`**
- JS를 사용하여 두 가지 뷰를 최소한의 연산으로 비교한 후, **`둘의 차이를 알아내 최소한의 연산으로 DOM 트리를 업데이트 한다.`**

**`결국 방식 자체는 루트 노드부터 시작하여 전체 컴포넌트를 처음부터 다시 렌더링항는 것처럼 보이지만, 사실 최적의 자원을 사용하여 이를 수행하는 것이다.`**

## Virtual DOM

- **DOM에는** 치명적인 문제점이 하나가 바로 **`동적 UI에 최적화되어 있지 않다.`**
- 스크롤바를 내릴수록 수 많은 데이터가 로딩 된다. 그리고 각 데이터를 표현하는 **요소(element)들이** 있고, 요소 개수가 몇 백개, 몇 천개 단위로 많다면 **성능 이슈가 생기게된다.**
- 하지만, **`DOM으로만 놓고 보면 자체는 빠르다.`**
  - **`DOM 자체를 읽고 쓸 때`** 성능은 JS 객체를 처리할 때 성능과 비교하여 `다르지 않다.`
  - 단, 웹 브라우저 단에서 DOM에 변화가 일어나면 `웹 브라우저가 CSS를 다시 연산하고, 레이아웃을 구성하고`, **`페이지를 repaint 한다.`** 이 과정에서 많은 시간이 할애된다.
- 이러한 문제점들을 해결하기 위해 리액트는 **`Virtual DOM 방식을`** 사용하여 **`DOM 업데이트를 추상화함으로써`** DOM처리 횟수를 최소화하고 효율적으로 진행한다.
- Virtual DOM을 사용하면 **`실제 DOM에 접근하여 조작하는 대신,`** 이를 **`추상화한 JS객체를 구성하여 사용한다.`** 마치 실제 DOM의 가벼운 사본과 비슷하다.
- DOM을 업데이트할 때 3가지 절차를 따른다.
  1. 데이터를 `업데이트 하면` 전체 UI를 **`Virtual DOM에 리렌더링한다.`**
  2. 이전 `Virtual DOM에 있던` 내용과 현재 **`내용을 비교한다.`**
  3. `바뀐 부분만` **`실제 DOM에 적용한다.`**

**주의 !!**
Virtual DOM을 사용한다고 해서 사용하지 않을 때와 비교하면 무조건 빠른것은 아니다.

```text
지속적으로 데이터가 변화하는 대규모 애플리케이션 구축하기
```